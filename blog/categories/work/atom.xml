<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: work | Liu.Shatle]]></title>
  <link href="http://shatle.github.com/blog/categories/work/atom.xml" rel="self"/>
  <link href="http://shatle.github.com/"/>
  <updated>2013-12-21T23:15:57+08:00</updated>
  <id>http://shatle.github.com/</id>
  <author>
    <name><![CDATA[liu.shatle &hearts; gmail.com]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Gemfile's gem reference with Rails app local]]></title>
    <link href="http://shatle.github.com/blog/2012/08/20/gemfiles-gem-reference-with-rails-app-local/"/>
    <updated>2012-08-20T15:51:00+08:00</updated>
    <id>http://shatle.github.com/blog/2012/08/20/gemfiles-gem-reference-with-rails-app-local</id>
    <content type="html"><![CDATA[<h2>Gemfile引用Rails项目中的gem</h2>

<hr />

<h3>需求</h3>

<p>之前写了个gem，但是不好意思让其他人在他们的机器上安装吧，因为是github上的私密的项目啊。需要下载下来，安装，虽然也不难。唉，废话。</p>

<h3>解决</h3>

<p>将我本地的已经安装好的gem，放到整个rails环境中吧。</p>

<p>解压本地gem到rails项目目录。</p>

<pre><code>gem unpack my-gem --target vendor/gems
</code></pre>

<p>往Gemfile里添加</p>

<pre><code>gem 'my-gem', '0.0.1', :path =&gt; "vendor/gems/my-gem-0.0.1"
</code></pre>

<p>然后, <code>bundle install</code>确认是否成功。</p>

<p>如果，在Gemfile上的版本号不写，或者写<code>&gt;=0.0.1</code>会出现错误。小白我不懂。
解压到本地的gem没有specification文件，不能准确识别版本？可能吧。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[a tip order of git commit file]]></title>
    <link href="http://shatle.github.com/blog/2012/08/20/a-tip-order-of-git-commit-file/"/>
    <updated>2012-08-20T14:46:00+08:00</updated>
    <id>http://shatle.github.com/blog/2012/08/20/a-tip-order-of-git-commit-file</id>
    <content type="html"><![CDATA[<hr />

<h2>git commit的顺序小记</h2>

<hr />

<p>我在本地从master分支中新建了一个关于此模块的分支 <code>test_job</code></p>

<pre><code>git checkout -b test_job
</code></pre>

<p>此命令会自动在本地创建<code>test_job</code>分支，并从本地分支切换到<code>test_job</code>分支的。</p>

<p>然后在此分支上做了许多的工作，当想提交的时候，我想了些。此前并不意识到，可能的与其他代码人员的代码冲突，结果往往另我很伤神。</p>

<p>这次应该多检查一下才行。</p>

<p>首先，查看状态。</p>

<pre><code>git status
</code></pre>

<p>很不幸，其中有一个文件是我没想修改的。但是不知道什么时候，可能是我的原因或者编辑器的原因，对这个文件创造出了修改。这里称此文件为 <code>app/model/other_job_model.rb</code>。</p>

<p>好吧，虽然说，我是不想改这文件的。但是，刚过周末，会不会是上周的一个小需求需要修改此文件，而这周的我忘却了呢？那先具体看看此文件有哪些改动吧。</p>

<pre><code>git diff HEAD -- app/model/other_job_model.rb
</code></pre>

<p>此命令会显示文件<code>app/model/other_job_model.rb</code>最后一次提交与当前代码的区别。这里的最后一次提交应该是从<code>master</code>迁出的最后一次提交。</p>

<blockquote><pre><code>   $ git diff test            (1)
   $ git diff HEAD -- ./test  (2)
   $ git diff HEAD^ HEAD      (3)
</code></pre>

<ol>
<li>Instead of using the tip of the current branch, compare with
the tip of "test" branch.</li>
<li>Instead of comparing with the tip of "test" branch, compare
with the tip of the current branch, but limit the comparison to
the file "test".</li>
<li>Compare the version before the last commit and the last
commit.</li>
</ol>
</blockquote>

<p>看了之后顿时无语，不知道什么时候手贱，对此文件删除了一空白行。而　git 神经紧张地报告了这一修改。好吧，至少我还是不希望这一修改提交的，虽然对他人的代码的运行不会有问题，但是，未知的东西太多了。我小白无知的太多了，别动他人代码为好。</p>

<pre><code>git checkout -- app/model/other_job_model.rb
</code></pre>

<p>相关语法：</p>

<blockquote><p>git checkout [-p|--patch] [&lt;tree-ish>] [--] [&lt;paths>...]</p></blockquote>

<p>重新查看状态</p>

<pre><code>git status
</code></pre>

<p>好了，此时的文件应该是我自己要修改的文件了。可以提交了。</p>

<pre><code>git add ./  #如果有删除或者更多非添加操作，可以　git add -A
git commit -m "test_job ok"
</code></pre>

<p>好了，此版本不会涉及到他人文件了。现在把此分支提交到远程吧。</p>

<pre><code>git push origin HEAD
</code></pre>

<p>完成，远程会自动创建<code>test_job</code>这一分支并包含刚才push的代码的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ubuntu one记事]]></title>
    <link href="http://shatle.github.com/blog/2012/08/17/ubuntu-one-ji-shi/"/>
    <updated>2012-08-17T21:48:00+08:00</updated>
    <id>http://shatle.github.com/blog/2012/08/17/ubuntu-one-ji-shi</id>
    <content type="html"><![CDATA[<p>前段时间，我不小心从ubuntu one官网上删除了我自己机器上的，于是其只剩下公司电脑了。</p>

<p>回到宿舍想重新添加时，一直不知道怎么办。</p>

<p>有人说，可以从ubuntu one的客户端点击，出网页，会出现添加此设备的按钮，实际上我的没有。</p>

<p>终于方法到了：</p>

<ul>
<li>删除本地的ubuntu one 帐号。</li>
</ul>


<p>打开"密码与密钥"程序，在"密码"中找到 ubuntu one 的行，右键删除。</p>

<ul>
<li><p>打开终端运行命令。</p>

<pre><code>  u1sdtool -q

  u1sdtool -c
</code></pre></li>
</ul>


<p>重启同步进程。</p>

<ul>
<li>打开ubuntu one的客户端，输入帐号，就没问题。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ps引出的<终端>知识点]]></title>
    <link href="http://shatle.github.com/blog/2012/08/17/ps-yin-chu-de-%3Czhong-duan-%3Ezhi-shi-dian/"/>
    <updated>2012-08-17T21:43:00+08:00</updated>
    <id>http://shatle.github.com/blog/2012/08/17/ps-yin-chu-de-<zhong-duan->zhi-shi-dian</id>
    <content type="html"><![CDATA[<p>由于任务可能要涉及到，进程的管理，所以，又稍微看了ps命令，其中的很多标识都不知道它是什么意思。</p>

<p>幸运的是，在查找ps相关信息的时候，我发现了一直未意识到的基础知识：</p>

<p>&lt;终端></p>

<p>于是我把这一相关信息copy下来，以后可能会重温一下。</p>

<blockquote><p>http://forum.ubuntu.org.cn/viewtopic.php?f=50&amp;t=150603</p></blockquote>

<p>终端是一种字符型设备，它有多种类型，通常使用tty来简称各种类型的终端设备。tty是Teletype的缩写。Teletype是最早出现的一种终端 设备，很象电传打字机（或者说就是），是由Teletype公司生产的。在Linux系统的设备特殊文件目录/dev/下，终端特殊设备文件一般有以下 几种：</p>

<p>1.串行端口终端（/dev/ttySn）</p>

<p>串行端口终端（Serial Port Terminal）是使用计算机串行端口连接的终端设备。计算机把每个串行端口都看作是一个字符设备。有段时间这些串行端口设备通常被称为终端设备，因为 那时它的最大用途就是用来连接终端。这些串行端口所对应的设备名称是/dev/tts/0（或/dev/ttyS0）、/dev/tts/1（或 /dev/ttyS1）等，设备号分别是（4,0）、（4,1）等，分别对应于DOS系统下的COM1、COM2等。若要向一个端口发送数据，可以在命令 行上把标准输出重定向到这些特殊文件名上即可。例如，在命令行提示符下键入：echo test > /dev/ttyS1会把单词”test”发送到连接在ttyS1（COM2）端口的设备上。可接串口来实验。</p>

<p>2.伪终端（/dev/pty/）</p>

<p>伪终端（Pseudo Terminal）是成对的逻辑终端设备，例如/dev/ptyp3和/dev/ttyp3（或着在设备文件系统中分别是/dev/pty/m3和 /dev/pty/s3）。它们与实际物理设备并不直接相关。如果一个程序把ttyp3看作是一个串行端口设备，则它对该端口的读/写操作会反映在该逻辑 终端设备对的另一个上面（ttyp3）。而ttyp3则是另一个程序用于读写操作的逻辑设备。这样，两个程序就可以通过这种逻辑设备进行互相交流，而其中 一个使用ttyp3的程序则认为自己正在与一个串行端口进行通信。这很象是逻辑设备对之间的管道操作。对于ttyp3（s3），任何设计成使用一个串行端 口设备的程序都可以使用该逻辑设备。但对于使用ptyp3的程序，则需要专门设计来使用ptyp3 （m3）逻辑设备。</p>

<p>例如，如果某人在网上使用telnet程序连接到你的计算机上，则telnet程序就可能会开始连接到设备ptyp2（m2）上（一个伪终端 端口上）。此时一个getty程序就应该运行在对应的ttyp2（s2）端口上。当telnet从远端获取了一个字符时，该字符就会通过m2、s2传递给 getty程序，而getty程序就会通过s2、m2和telnet程序往网络上返回”login:”字符串信息。这样，登录程序与telnet程序就通 过“伪终端”进行通信。通过使用适当的软件，就可以把两个甚至多个伪终端设备连接到同一个物理串行端口上。</p>

<p>在使用设备文件系统（device filesystem）之前，为了得到大量的伪终端设备特殊文件，使用了比较复杂的文件名命名方式。因为只存在16个ttyp（ttyp0—ttypf） 的设备文件，为了得到更多的逻辑设备对，就使用了象q、r、s等字符来代替p。例如，ttys8和ptys8就是一个伪终端设备对。不过这种命名方式目前 仍然在RedHat等Linux系统中使用着。 但Linux系统上的Unix98并不使用上述方法，而使用了”pty master”方式，例如/dev/ptm3。它的对应端则会被自动地创建成/dev/pts/3。这样就可以在需要时提供一个pty伪终端。目录 /dev/pts是一个类型为devpts的文件系统，并且可以在被加载文件系统列表中看到。虽然“文件”/dev/pts/3看上去是设备文件系统中的 一项，但其实它完全是一种不同的文件系统。</p>

<p>即TELNET --TTYP3（S3：slave）--TTYP3（M3：master）--GETTY</p>

<p>实验：1、在X下打开一个orN个N终端窗口
2、#ls /dev pt*
3、关闭这个X下的终端窗口，再次运行；比较两次输出信息就明白了。
在RHEL4环境下：输出为 /dev/ptmx /dev/pts/1 存在一（master）对多（slave）的情况</p>

<p>3.控制终端（/dev/tty）</p>

<p>如果当前进程有控制终端（Controlling Terminal）的话，那么/dev/tty就是当前进程的控制终端的设备特殊文件。可以使用命令”ps –ax”来查看进程与哪个控制终端相连。对于你登录的shell，/dev/tty就是你使用的终端，设备号是（5,0）。使用命令”tty”可以查看它 具体对应哪个实际终端设备。/dev/tty有些类似于到实际所使用终端设备的一个联接。</p>

<p>4.控制台终端（/dev/ttyn, /dev/console）</p>

<p>在Linux系统中，计算机显示器通常被称为控制台终端（Console）。它仿真了类型为Linux的一种终端（TERM=Linux）， 并且有一些设备特殊文件与之相关联：tty0、tty1、tty2等。当你在控制台上登录时，使用的是tty1。使用Alt+[F1—F6]组合键时，我 们就可以切换到tty2、tty3等上面去。tty1 –tty6等称为虚拟终端，而tty0则是当前所使用虚拟终端的一个别名，系统所产生的信息会发送到该终端上。因此不管当前正在使用哪个虚拟终端，系统信 息都会发送到控制台终端上。你可以登录到不同的虚拟终端上去，因而可以让系统同时有几个不同的会话期存在。只有系统或超级用户root可以向/dev /tty0进行写操作 即下例：</p>

<pre><code>#tty（查看当前TTY）
/dev/tty1
＃echo "test tty0" &gt; /dev/tty0
test tty0
</code></pre>

<p>5.其它类型</p>

<p>Linux系统中还针对很多不同的字符设备存在有很多其它种类的终端设备特殊文件。例如针对ISDN设备的/dev/ttyIn终端设备等。这里不再赘述。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[rails lib 文件]]></title>
    <link href="http://shatle.github.com/blog/2012/08/17/rails-lib-wen-jian/"/>
    <updated>2012-08-17T21:42:00+08:00</updated>
    <id>http://shatle.github.com/blog/2012/08/17/rails-lib-wen-jian</id>
    <content type="html"><![CDATA[<p>今天在rails项目中的<code>rails_dir/lib</code>文件夹新建了个文件，当类库使用。</p>

<p>如：my_jobs.rb，内容如下:</p>

<pre><code>module Jobs
  def self.hello
    "hello"
  end
end
</code></pre>

<p>但是，当我用</p>

<pre><code>rails c
</code></pre>

<p>并不能正常加载，不是说rails项目的lib中的文件会自动加载吗？问了旁边的齐洋，哦，要模块名与文件名要同名(符合rails规则)，才能自动加载。</p>

<p>唉，之前都是习惯同名，现在不同名却能发现这一问题。多coding，才能发现问题啊。</p>
]]></content>
  </entry>
  
</feed>
